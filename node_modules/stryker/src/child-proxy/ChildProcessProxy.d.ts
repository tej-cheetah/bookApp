import LoggingClientContext from '../logging/LoggingClientContext';
declare type Func<TS extends any[], R> = (...args: TS) => R;
declare type PromisifiedFunc<TS extends any[], R> = (...args: TS) => Promise<R>;
interface Constructor<T, TS extends any[]> {
    new (...args: TS): T;
}
export declare type Promisified<T> = {
    [K in keyof T]: T[K] extends PromisifiedFunc<any, any> ? T[K] : T[K] extends Func<infer TS, infer R> ? PromisifiedFunc<TS, R> : () => Promise<T[K]>;
};
export default class ChildProcessProxy<T> {
    readonly proxy: Promisified<T>;
    private readonly worker;
    private readonly initTask;
    private disposeTask;
    private currentError;
    private readonly workerTasks;
    private readonly log;
    private readonly stdoutAndStderrBuilder;
    private isDisposed;
    private constructor();
    /**
     * @description Creates a proxy where each function of the object created using the constructorFunction arg is ran inside of a child process
     */
    static create<T, TS extends any[]>(requirePath: string, loggingContext: LoggingClientContext, plugins: string[], workingDirectory: string, _: Constructor<T, TS>, ...constructorArgs: TS): ChildProcessProxy<T>;
    private send;
    private initProxy;
    private forward;
    private listenForMessages;
    private listenToStdoutAndStderr;
    private reportError;
    private handleUnexpectedExit;
    private handleError;
    private innerProcessIsCrashed;
    dispose(): Promise<void>;
    private logUnidentifiedMessage;
}
export {};
