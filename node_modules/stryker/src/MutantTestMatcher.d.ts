import { RunResult } from 'stryker-api/test_runner';
import { StrykerOptions, File } from 'stryker-api/core';
import { Mutant } from 'stryker-api/mutant';
import TestableMutant from './TestableMutant';
import StrictReporter from './reporters/StrictReporter';
import { CoverageMapsByFile } from './transpiler/CoverageInstrumenterTranspiler';
import SourceMapper from './transpiler/SourceMapper';
export default class MutantTestMatcher {
    private readonly mutants;
    private readonly filesToMutate;
    private readonly initialRunResult;
    private readonly sourceMapper;
    private readonly coveragePerFile;
    private readonly options;
    private readonly reporter;
    private readonly log;
    constructor(mutants: ReadonlyArray<Mutant>, filesToMutate: ReadonlyArray<File>, initialRunResult: RunResult, sourceMapper: SourceMapper, coveragePerFile: CoverageMapsByFile, options: StrykerOptions, reporter: StrictReporter);
    private readonly baseline;
    matchWithMutants(): TestableMutant[];
    enrichWithCoveredTests(testableMutant: TestableMutant): void;
    private isCoveredByBaseline;
    private isCoveredByTest;
    private isCoveredByCoverageCollection;
    private createTestableMutants;
    /**
     * Map the Mutant object on the MatchMutant Object.
     * @param testableMutant The mutant.
     * @returns The MatchedMutant
     */
    private mapMutantOnMatchedMutant;
    private findMatchingStatement;
    /**
     * Finds the smallest statement that covers a location
     * @param needle The location to find.
     * @param haystack the statement map or function map to search in.
     * @returns The index of the smallest statement surrounding the location, or null if not found.
     */
    private findMatchingStatementInMap;
    private findCoverageCollectionForTest;
    private isCoveragePerTestResult;
}
